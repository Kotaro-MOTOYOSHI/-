%#####################################################################
\chapter{関連技術}
%#####################################################################

　本研究では、提案したネットワークモデルをネットワークシミュレータを用いて構築しシミュレーションを行う。
本章では、2.1節で使用するネットワークシミュレータの説明を行い、2.2節では本研究の柱となるOpenFlow技術の説明をし、最後に2.3節では、ネットワークモデルを構築する際に必要となるネットワークの諸技術を説明する。

\section{ネットワークシミュレータ ns-3}

ns-3(Network Simulator Version 3)\cite{ns3} \cite{ns3text} とは、その前身であるns-2の開発に携わっている主要メンバーにより、オープンソースベース形式の離散イベント駆動型シミュレータである。
ns-3の開発チームには、Tom Henderson主任研究員を筆頭に、副主任研究員としてSumit Roy(ワシントン大学)、George Riley(ジョージア工科大学)、Sally Floyd(カリフォルニア大学バークレイ分校ISCIセンター)など、ネットワークの研究分野において著名な研究者たちが名を連ねている。
無料で使用可能なシミュレータながら、最新のサービスやプロトコルのサポートを行うなどの積極的な開発を行っているため、近年では一般的になりつつある。

ns-3は、有線でのパケット通信しか想定されていなかったなど数々の問題点があったns-2の問題点を解消し、ns-2の開発時点ではなかった新たなプロトコルの実装および、より大規模なシミュレーションの評価をより簡単にする目的で開発された。
これにより、ns-2でのシナリオ記述で採用していたObject TCL言語を廃止し、事実上C++でのデザインに統一したため、ns-3とns-2の間の互換性が無くなってしまった。
そのため、有線ネットワーク系のシミュレーションにはns-2を、無線ネットワーク系および比較的新しい技術を用いたネットワークのシミュレーションにはns-3を使うのが一般的であったが、現在では、ns-2の機能の完全移植が着実に進んでおり、徐々にns-3のシェアが高まっている。 \\

ns-3には、本研究で用いるOpenFlowに対応しているほかに、以下の機能を備える。

\subsubsection{Pythonによるシナリオファイルの作成}

ns-3は、C++言語でのデザインに統一されたが、シミュレーションするネットワークモデルの構築を行うシナリオファイルの記述には簡易スクリプト言語であるPythonも使用することができる。
Pythonを用いてシナリオファイルを作成することによって、コード量および可読性を高まり、第三者が見ても分かりやすいシナリオファイルを作成することができる。

本研究では、ns-3がOpenFlowのPythonバインディングに対応していないということと、Pythonの欠点である実行速度の遅さが如実に表れる可能性があるということから、C++を用いてコーディングを行っている。

\subsubsection{tcpdumpを用いたトレースファイルの解析}

シナリオファイルにトレースファイルの生成を可能にするコードを追加することで、シナリオにある全てのノードの全ての物理ポートに対して、パケットの入力、出力のデータを持つパケットキャプチャ用ライブラリのlibpcap形式（以下、PCAP形式）のトレースファイルを生成する。
これをLinuxに標準搭載されているキャプチャツールであるtcpdumpを用いることで、PCAP形式のトレースファイルを解析することが可能である。

\subsubsection{シミュレーション結果の可視化}

ns-3では、PyVizというライブラリを用いることによって、トレースファイルを用いたシミュレーション結果のアニメーション表示が可能である。
PyVizは最新のns-3パッケージに標準搭載されており、パケットの通信経路、パケットの転送速度などを可視化して表示することができ、シミュレーション結果の時間的な流れを柔軟に変更させながら、結果の解析ができる。

\subsubsection{実機を用いたシミュレーションをサポート}

% 「やったねたえちゃん、ns-3にはopenflowのコントローラとかIDSとかの実機をつなぐプロトコルが用意されてて、それを用いると実機を一部かませた実験ができるよ」「おいやめろ（切実）」
%　「ちなみに、この技術使えば実際流れてるトラフィックをシミュレータ上に流し込んで解析することもできるゾ」「やりますねぇ～」

ns-3には、LinuxなどのUNIX系OSに搭載されているTAP/TUNデバイスを用いて、実際に動作しているホストやデバイスなどをシミュレーションに統合させることができる \cite{tapdevice}。


\section{SDNとOpenFlow}

\subsection{SDN}

従来のネットワークは、スイッチおよびルータが自律的にネットワークの情報を収集し、その情報に応じてパケット通信を行ってきた\cite{openflownet}。
このとき、ネットワーク管理者が制御できる部分はあまりに限定的であったため、ネットワークユーザのニーズの多様化に対応できないなどの課題があった。
この課題を解決するために、ソフトウェアのように柔軟にネットワーク機器の制御機構を変更する技術が求められた。
このようにして考えられた技術の総称がSDN(Software Defined Network)である。

\subsection{OpenFlow}

OpenFlowとは、SDNを用いた代表的なプロトコルで、ネットワーク機器のハードウェアレベルまでの機能の制御を行うことができる技術である\cite{openflowjapanese}。

OpenFlowを用いることで、自身で柔軟にネットワーク環境を構築し、運用する事ができる。
これにより、従来は時間をかけなければならなかったネットワーク環境の変更にも、ソフトウェアのようにコードを変更するだけで対応ができるようになり、比較的短時間で進めることができる。
更に、OpenFlow対応機器を購入し、自身でプログラムすることによって構築するため、運用コストが低いという利点がある。

\subsection{OpenFlowの仕様}

OpenFlowプロトコルには、主にスイッチをどのように振る舞わせるかを規定したもので、コントローラおよびアプリケーションを用いて定義する必要がある。


2008年12月に策定されたOpenFlow　Version 0.8.9\cite{openflow}　から仕様が公開された。
以下よりOpenFlowの仕様について述べる。

\subsubsection{マッチフィールド}

OpenFlowで用いるマッチフィールドを表 \ref{tab:2-1}に示す\cite{openflow}。
スイッチが予め空のフローテーブルを保有しており、入力されたパケットがフローテーブルのマッチフィールドに合致しなければ、スイッチ自身が未知のパケットと判断し、パケットの制御方法をコントローラに問い合わせる。
スイッチからコントローラに問い合わせが来たとき、コントローラ自身に記述されているアルゴリズムをもとにマッチする処理をスイッチに伝える。
コントローラから処理手順を伝えられたスイッチは、そのパケットを手順通りに処理したあと、自身のフローテーブルに追加する。

\begin{table}[tb]
	\begin{center}
		\caption{OpenFlowで用いるマッチフィールド}
		\begin{tabular}{c|c}
			\hline \hline
			フィールド & 内容　\\ \hline
			Ingress Port & 受信物理ポート　\\
			Ethernet source address & 送信元MACアドレス \\
			Ethernet destination address & 宛先MACアドレス　\\
			Ethernet type & パケットのプロトコルタイプ \\
			VLAN id & VLAN ID(Ethernet typeが0x8100のみ)　\\
			IP source address & 送信元IPアドレス　\\
			IP destination address & 宛先IPアドレス　\\
			IP protocol & TCP/IPのプロトコル番号　\\
			Transport source port & 送信元のポート番号　\\
			Transport destination port & 宛先のポート番号\\ \hline
		\end{tabular}
		\label{tab:2-1}
	\end{center}
\end{table}

\subsubsection{アクション}

マッチフィールドを用いてマッチングされたパケットの処理を以下の4つから決定する\cite{openflowjapanese}。
4つの処理の中から複数選択することが可能であり、基本的にはパケットの破棄を除く3つを自由に組み合わせてパケットの処理を行う。

\begin{itemize}
	\item パケット転送
	\item パケットヘッダの変更
	\item パケットのエンキュー
	\item パケット破棄
\end{itemize}

パケット転送では、入力されたパケットを指定の物理ポートへ転送する。
このとき、物理ポートを指定するほかに、OpenFlowに用意された仮想ポートを指定することができる。
主に使用する仮想ポートには、表 \ref{tab:2-2}がある。

% 要改善 (表のはみだし)

\begin{table}[tb]
	\begin{center}
		\caption{パケット転送で使用できる仮想ポート}
		\begin{tabular}{c|c}
			\hline \hline
			仮想ポート名 & 内容　\\ \hline
			OFPP\_ALL & 全ての物理ポートへ転送　\\
			　& (入力ポートを除く)　\\
			OFPP\_CONTROLLER & コントローラへ転送 \\
			OFPP\_IN\_PORT & 入力ポートへ転送　\\
			OFPP\_NORMAL & 通常のスイッチと同じ振る舞い　\\
			OFPP\_FLOOD & 全ての物理ポートへ転送　\\
			 & (入力ポートおよび規制されたポートを除く) \\ \hline
		\end{tabular}
		\label{tab:2-2}
	\end{center}
\end{table}

パケットヘッダの変更は、入力されたパケットのヘッダフィールドを変更することができる。
そのとき、各フレームのチェックサムも同時に再計算され変更する。
変更可能なヘッダフィールドの処理を以下に示す。

\begin{itemize}
	\item VLAN IDの変更
	\item VLAN優先度の変更
	\item VLANタグの除去(タグVLAN使用時のみ)
	\item 送信元MAC addressの変更
	\item 宛先MAC addressの変更
	\item 送信元IP addressの変更
	\item 宛先IP addressの変更
	\item パケット処理の優先度を示すToSフィールドの変更
	\item 送信元のポート番号の変更
	\item 宛先のポート番号の変更
\end{itemize}

パケットのエンキューは、OpenFlowスイッチ内にキューを持っているとき、それぞれの物理ポートのキューにエンキューをすることができる。
パケットの破棄は、フローエントリーにパケットの転送処理がない場合、そのパケットを破棄するという仕様を利用して、作為的に空のフローエントリーを作成することで実装できる。

% まだ書くかも

\section{ネットワークモデル構築に必要な諸技術}

\subsection{MACアドレス}

MACアドレスとは、データリンクに接続されているノードを識別するためにIEEEが規格化した48ビットで構成されているユニークなアドレスである\cite{masteringtcpip}。
一般的なコンピュータに搭載されているNICの場合はマザーボードなどに焼きこまれており、このときにMACアドレスのユニーク性が保証される。
MACアドレスは通常「9E-0D-FE-54-A9-F9」や「1D:98:D2:69:EC:76」など、8ビット列の6組に分け16進数表記で記載し、3～24ビットにはNICの製造メーカーごとに特定の数字が割り振られたベンダ識別子が、25～48ビットにはメーカーが製造したNICごとに違う製造番号が割り当てられている。

これにより、ネットワークの異常を検知した際に疑わしいフレームを解析し、MACアドレスを調べることによって、どのメーカーのNICで異常なフレームを送信しているかを特定することができる。
これは、ネットワークがマルチベンダ環境で構築されている場合の原因特定に役立つ場合もある。

このMACアドレスは、データリンクの種類にかかわらずユニークになるように割り当てられるため、イーサネットと無線LAN、Bluetoothなどデータリンクの種類が異なる通信が同じコンピュータ内に存在する場合でも、同じアドレスが割り当てられることはない。

\subsection{IPアドレス}

IPアドレスとは、インターネットにある全てのホストおよびルータが所持しているアドレスである\cite{tanenbaum}。
現在一般的に使用されているIPv4は32ビットで構成されており、IPパケット上で送信元アドレスと宛先アドレスの指定に用いられている。
通常、人間でも分かりやすくするために、「33.205.102.82」32ビットを8ビット列の4組に分け、10進数表記で記載する。

IPアドレスはMACアドレスとは異なり、階層構造を持っている\cite{masteringtcpip}。
32ビットのIPアドレスのうち、上位ビットをネットワーク部、下位ビットをホスト部と呼び、ビット長は可変長である。
ネットワーク部はデータリンクのセグメントごとに割り振られており、全てのセグメントのアドレスと重複しないように設定しなければならない。
このため同じセグメントに接続されているホストは、ネットワーク部のビット列が同じである。
一方、ホスト部は同じセグメント内のホスト同士が重複しないように設定される。
これによりネットワーク全体でユニークなIPアドレスを割り当てることができる。

しかし、ネットワーク部とホスト部は合計32ビットであるという制約のもと、ビット長は可変長であるため、IPアドレスだけではそれぞれのビット長がどれほどかを判断することはできない。
この問題の解決方法は主に2種類ある。

初期のIPでは、ネットワーク部とホスト部はクラスA～Dおよび未使用のクラスEによって区別されていた。
これらは表 \ref{tab:2-3}のように各クラスにおいて、使用できるアドレスの範囲、用途を定義している。
しかし、クラスによるネットワーク部とホスト部の区別は融通が利きにくく、上位のクラスをそのまま使うのは無駄などの問題点が指摘されていた。

\begin{table}[tb]
	\begin{center}
		\caption{IPにおけるクラスの特徴}
		\begin{tabular}{c|c|c|c}
			\hline \hline
			クラス名 & ネットワークアドレスの範囲 & ビット長 & 用途　\\ \hline
			クラスA & 0.0.0.0～127.0.0.0 & 8ビット & 大規模ネットワーク\\
			クラスB & 128.0.0.0～191.255.0.0 & 16ビット & 中規模ネットワーク \\
			クラスC & 192.0.0.0～223.255.255.0 & 24ビット & 小規模ネットワーク \\
			クラスD & 224.0.0.0～239.255.255.255 & 32ビット & IPマルチキャスト通信\\
			クラスE & & & 実験用　\\ \hline
		\end{tabular}
		\label{tab:2-3}
	\end{center}
\end{table}

現在のIPでは、クラスの考え方を継承し、以前の問題点を縮小したサブネットマスクにより区別している。
つまり、現在はIPアドレスを通常のアドレスとサブネットマスクの2種類の識別子で表すようになった。

サブネットマスクは、IPアドレスと同じく32ビットで、IPアドレスのネットワーク部を表すビットをすべて1に、ホスト部を表すビットをすべて0にして表記する。
例えば、IPアドレスの上位25ビットがネットワーク部であった場合、サブネットマスクの上位25ビットを1に、下位7ビットを0にした「255.255.255.128」がサブネットマスクということになる。
これにより、ネットワーク部のビット長をクラスに縛られることなく柔軟に変えることができるようになった。