%#####################################################################
\chapter{関連技術}
%#####################################################################

　本研究では，提案したネットワークモデルをネットワークシミュレータを用いて構築しシミュレーションを行う．
本章では，始めの2.1節で，使用するネットワークシミュレータの説明を行い，2.2節ではSDNおよびOpenFlow技術の説明を行う．最後に2.3節では，ネットワークモデルを構築する際に必要となるネットワークの諸技術について説明する．

\section{ネットワークシミュレータ ns-3}

ns-3(Network Simulator Version 3)\cite{ns3} \cite{ns3text} とは，その前身であるns-2の開発に携わっている主要メンバーにより開発された，オープンソースベースの離散イベント駆動型シミュレータである．
ns-3の開発チームには，Tom Henderson主任研究員を筆頭に，副主任研究員としてSumit Roy(ワシントン大学)，George Riley(ジョージア工科大学)，Sally Floyd(カリフォルニア大学バークレイ分校ISCIセンター)など，ネットワークの研究分野において著名な研究者たちが名を連ねている．
無料で使用可能なシミュレータながら，比較的最近のサービスやプロトコルのサポートを行うなどの積極的な開発を行っている．

ns-3が開発された目的は，有線でのパケット通信しか想定されていなかったなど数々あったns-2の問題点を解消し，ns-2の開発時点では存在しなかった新たなプロトコルの実装および，より大規模なシミュレーションの評価をより簡単にするというものであった．
それに伴い，ns-2でのシナリオを記述する言語として採用していたObject TCL言語の使用を廃止し，事実上C++言語を用いたデザインに統一したため，ns-3とns-2の間の互換性が無くなってしまった．
そのため，長らくは有線ネットワーク系のシミュレーションにはns-2を，無線ネットワーク系および比較的新しい技術を用いたネットワークのシミュレーションにはns-3を使うのが一般的であったが，現在では，ns-2の機能の完全移植が着実に進んでおり，徐々にns-3を用いるユーザ多くなっている． \\

ns-3には，本研究で用いるOpenFlow技術に対応しているほかに，以下の機能を備える．

\subsubsection{Pythonによるシナリオファイルの作成}

ns-3は，C++言語でのデザインに統一されたが，シミュレーションするネットワークモデルの構築を行うシナリオファイルの記述には，簡易スクリプト言語であるPythonも使用することができる．
Pythonを用いてシナリオファイルを作成することによって，コード量の削減および可読性が高まり，第三者が見ても分かりやすいシナリオファイルを作成することができる．

本研究では，ns-3がOpenFlowのPythonバインディングに対応していないということと，Pythonの弱点である実行速度の遅さが如実に表れる可能性があるということから，C++言語を用いてシナリオファイルを作成している．

\subsubsection{tcpdumpを用いたトレースファイルの解析}

シナリオファイルにトレースファイルの生成を可能にするコードを追加することで，シナリオに存在する全てのノードの全てのデバイスに対して，パケットの入力，出力のデータを持つパケットキャプチャ用ライブラリのlibpcap形式（以下，PCAP形式）のトレースファイルを生成することができる．
このファイルをLinuxに標準搭載されているキャプチャツールであるtcpdumpを用いて解析することが可能であり，様々な視点からネットワークの全体像を把握することが可能になる．

\subsubsection{シミュレーション結果の可視化}

ns-3では，PyVizというライブラリを用いることによって，トレースファイルを用いたシミュレーション結果のアニメーション表示が可能になる．
PyVizは最新のns-3パッケージに標準搭載されているため，特別な導入操作などは不要である．
パケットの通信経路，転送速度などを可視化して表示することができ，シミュレーション結果の時間的な流れを柔軟に変更させながら，結果の解析ができる．

\subsubsection{実機を用いたシミュレーション}

ns-3には，LinuxなどのUNIX系OSに搭載されているTAPデバイスを用いて，現実で動作しているホストやデバイスなどをシミュレーション内に統合させることができる．
これを用いることによって，実際に稼働している通信の一部をシミュレータ内に引き込んでシミュレーションを行うことが可能になるほか，ns-3外でインストールしたソフトウェアと接続させてシミュレーションを行うことが可能になる．

\section{SDNとOpenFlow}

本節では，ネットワークモデルを構築する際に採用した技術であるSDNおよびOpenFlow技術についての説明を行う．
OpenFlow技術に関しては，本研究で活用したOpenFlowの仕様も併せて説明する．

\subsection{SDN}

従来のネットワークは，スイッチおよびルータが自律的にネットワークの情報を収集し，その情報に応じてパケット通信を行ってきた\cite{openflownet}．
そのため，ネットワーク管理者が制御できる部分はあまりに限定的であり，ユーザのニーズの多様化に対応できないなどの課題があった．
更に，従来のネットワークは大部分の構成が静的であるという前提のうえで，ネットワークの構築を行っていたため，構成を何らかの事情で変更しなければならないとき，従来の方法ではほぼ全てを手作業で変更する必要があり，非常に苦労するものであった．
このような課題を解決するために，ソフトウェアのように柔軟および動的に，経路情報などのネットワーク機器の制御を行う技術が求められた．
このようにして考えられた技術の総称がSDN(Software Defined Network)である．

SDNは，しばしば「ソフトウェアでプログラムするように自由にネットワークの構成を変更できるようなネットワーク」と意味で用いられ\cite{openflowjapanese}，現在ではプログラム自動生成，デバッガなど一般的なソフトウェアと遜色ないような機能を加えることはできないかというような議論が行われている．

\subsection{OpenFlow}

OpenFlowとは，SDNを用いた代表的なプロトコルで，ネットワーク機器のハードウェアレベルまでの機能の制御を行うことができる技術である\cite{openflowjapanese}．

OpenFlowを用いることで，ネットワーク管理者自身で柔軟にネットワーク環境を構築し，運用する事ができる．
これにより，従来は大きな時間と労力をかけなければならなかったネットワーク環境の変更にも，ソフトウェアのようにコードを変更するだけで，ほぼ全て対応できるようになり，比較的短時間で行うことができるようになる．
更に，OpenFlow対応機器を購入し，自身でプログラムすることによって自由にネットワークを構築するため，運用コストが低いという利点がある．

未だ研究段階で実用・一般化されておらず，目途も明らかになっていないが，日本の企業や大学からもこの技術に関する研究や実装事例が多数報告されており，注目が集まっている技術である．

\subsection{OpenFlowの仕様}

OpenFlowプロトコルは，主にスイッチをどのように振る舞わせるかを規定したもので，コントローラおよびアプリケーションを用いて定義する必要がある．

2008年12月に策定されたOpenFlow　Version 0.8.9\cite{openflow}　から仕様が一般公開されており，執筆現在の最新バージョンは1.5.1である．
今回使用したOpenFlowモジュールはバージョン0.8.9を用いてモデルを構築しているため，以下に述べるOpenFlowの仕様は，バージョン0.8.9に基づくものである．

\subsubsection{マッチフィールド}

OpenFlowで用いるマッチフィールドを表 \ref{tab:2-1}に示す\cite{openflow}．

スイッチが予め空のフローテーブルを保有しており，入力されたパケットがフローテーブル内のフローエントリーのマッチフィールドに合致しなければ，スイッチ自身が未知のパケットと判断し，パケットの制御方法をコントローラに問い合わせる．
スイッチからコントローラに問い合わせが来たとき，コントローラに記述されているアルゴリズムをもとに適切な処理をスイッチに伝える．
コントローラから処理手順を伝えられたスイッチは，自身のフローテーブルに処理を追加した後，そのパケットを手順通りに処理する．

フローテーブル内のフローエントリーのマッチフィールドに完全に合致したパケットであれば，スイッチはコントローラに問い合わせることなく，自律的にフローに基づいてパケットの処理を行う．
マッチングする際に，ワイルドカードを用いることも可能である．

\begin{table}[tb]
	\begin{center}
		\caption{OpenFlowで用いるマッチフィールド}
		\begin{tabular}{c|c}
			\hline \hline
			フィールド & 内容　\\ \hline
			Ingress Port & 受信物理ポート　\\
			Ethernet source address & 送信元MACアドレス \\
			Ethernet destination address & 宛先MACアドレス　\\
			Ethernet type & パケットのプロトコルタイプ \\
			VLAN id & VLAN ID(Ethernet typeが0x8100のみ)　\\
			IP source address & 送信元IPアドレス　\\
			IP destination address & 宛先IPアドレス　\\
			IP protocol & TCP/IPのプロトコル番号　\\
			Transport source port & 送信元のポート番号　\\
			Transport destination port & 宛先のポート番号\\ \hline
		\end{tabular}
		\label{tab:2-1}
	\end{center}
\end{table}

\subsubsection{アクション}

マッチフィールドを用いてマッチングされたパケットの処理を以下の4つから決定する\cite{openflowjapanese}．
4つの処理の中から複数選択することが可能であり，基本的にはパケットの破棄を除く3つを自由に組み合わせてパケットの処理を行う．

\begin{itemize}
	\item パケット転送
	\item パケットヘッダの変更
	\item パケットのエンキュー
	\item パケット破棄
\end{itemize}

パケット転送では，入力されたパケットを指定の物理ポートへ転送する．
このとき，物理ポートを指定するほかに，OpenFlowに用意された仮想ポートを指定することができる．
仮想ポートを指定した場合，表 \ref{tab:2-2}にある内容に合致した物理ポートからパケットが出力される．

% 要改善 (表のはみだし)

\begin{table}[tb]
	\begin{center}
		\caption{パケット転送で使用できる代表的な仮想ポート}
		\begin{tabular}{c|c}
			\hline \hline
			仮想ポート名 & 内容　\\ \hline
			OFPP\_ALL & 全ての物理ポートへ転送　\\
			　& (入力ポートを除く)　\\
			OFPP\_CONTROLLER & コントローラへ転送 \\
			OFPP\_IN\_PORT & 入力ポートへ転送　\\
			OFPP\_NORMAL & 通常のスイッチと同じ振る舞い　\\
			OFPP\_FLOOD & 全ての物理ポートへ転送　\\
			 & (入力ポートおよび規制されたポートを除く) \\ \hline
		\end{tabular}
		\label{tab:2-2}
	\end{center}
\end{table}

パケットヘッダの変更は，入力されたパケットのヘッダフィールドを変更することができる．
そのとき，各フレームのチェックサムも同時に再計算され変更される．
変更可能なヘッダフィールドの処理を以下に示す．

\begin{itemize}
	\item VLAN IDの変更
	\item VLAN優先度の変更
	\item VLANタグの除去(タグVLAN使用時のみ)
	\item 送信元MAC addressの変更
	\item 宛先MAC addressの変更
	\item 送信元IP addressの変更
	\item 宛先IP addressの変更
	\item パケット処理の優先度を示すToSフィールドの変更
	\item 送信元のポート番号の変更
	\item 宛先のポート番号の変更
\end{itemize}

パケットのエンキューは，OpenFlowスイッチ内にキューを持っているとき，それぞれの物理ポートのキューにエンキューをすることができる．

パケットの破棄は，フローエントリーは存在するが転送処理が規定されていない場合，そのパケットを破棄するという仕様を利用して，作為的に空のフローエントリーを作成することで実現できる．

\section{ネットワークモデル構築に必要な諸技術}

\subsection{MACアドレス}

MACアドレスとは，データリンクに接続されているノードを識別するためにIEEEが規格化した48ビットで構成されているユニークなアドレスである\cite{masteringtcpip}．
一般的なコンピュータに搭載されているNIC(ネットワーク・インタフェース・カード)の場合はマザーボードなどに焼きこまれており，このときにMACアドレスのユニーク性を保証するように設定される．
MACアドレスは通常「9E-0D-FE-54-A9-F9」や「1D:98:D2:69:EC:76」など，8ビット列の6組に分け16進数表記で記載する．
3～24ビットにはNICの製造メーカーごとに特定の数字が割り振られたベンダ識別子が，25～48ビットにはメーカーが製造したNICごとに違う製造番号が割り当てられている．

これにより，ネットワークの異常を検知した際に疑わしいフレームを解析し，MACアドレスを調べることによって，どのメーカーのNICで異常なフレームを送信しているかを特定することができる．
これは，ネットワークがマルチベンダ環境で構築されている場合の原因特定に役立つ場合もある．

このMACアドレスは，データリンクの種類にかかわらずユニークになるように割り当てられるため，イーサネットと無線LAN，Bluetoothなどデータリンクの種類が異なる通信が同じコンピュータ内に存在する場合でも，同じアドレスが割り当てられることはない．

\subsection{IPアドレス}

IPアドレスとは，インターネットにある全てのホストおよびルータが保持しているアドレスである\cite{tanenbaum}．
現在一般的に使用されているIPv4は32ビットで構成されており，IPパケット上で送信元アドレスと宛先アドレスの指定に用いられている．
通常，人間でも認識しやすくするために，「33.205.102.82」というように32ビットを8ビット列の4組に分け，10進数表記で記載する．

IPアドレスはMACアドレスとは異なり，階層構造を持っている\cite{masteringtcpip}．
32ビットのIPアドレスのうち，上位ビットをネットワーク部，下位ビットをホスト部と呼び，ビット長は可変長である．
ネットワーク部はデータリンクのセグメントごとに割り振られており，全てのセグメントのアドレスと重複しないように設定しなければならない．
このため同じセグメントに接続されているホストは，ネットワーク部のビット列が同じである．
一方，ホスト部は同じセグメント内のホスト同士が重複しないように設定される．
これによりネットワーク全体でユニークなIPアドレスを割り当てることができる．

しかし，ネットワーク部とホスト部は合計32ビットであるという制約のもと，ビット長は可変長であるため，IPアドレスだけではそれぞれのビット長がどれほどかを判断することはできない．
この問題の解決方法は主に2種類ある．

初期のIPでは，ネットワーク部とホスト部はクラスA～Dおよび未定義のクラスEによって区別されていた．
これらは表 \ref{tab:2-3}のように各クラスにおいて，使用できるアドレスの範囲，用途を定義している．
しかし，クラスによるネットワーク部とホスト部の区別は融通が利きにくく，上位のクラスをそのまま使うのは無駄などの問題点が指摘されていた．

\begin{table}[tb]
	\begin{center}
		\caption{IPにおけるクラスの特徴}
		\begin{tabular}{c|c|c|c}
			\hline \hline
			クラス名 & ネットワークアドレスの範囲 & ビット長 & 用途　\\ \hline
			クラスA & 0.0.0.0～127.0.0.0 & 8ビット & 大規模ネットワーク\\
			クラスB & 128.0.0.0～191.255.0.0 & 16ビット & 中規模ネットワーク \\
			クラスC & 192.0.0.0～223.255.255.0 & 24ビット & 小規模ネットワーク \\
			クラスD & 224.0.0.0～239.255.255.255 & 32ビット & IPマルチキャスト通信\\
			クラスE & & & 実験用　\\ \hline
		\end{tabular}
		\label{tab:2-3}
	\end{center}
\end{table}

現在のIPでは，クラスの考え方を継承し，以前の問題点を縮小したサブネットマスクにより区別している．
つまり，現在はIPアドレスを通常のアドレスとサブネットマスクの2種類の識別子で表すようになった．

サブネットマスクは，IPアドレスと同じく32ビットで，IPアドレスのネットワーク部を表すビットをすべて1に，ホスト部を表すビットをすべて0にして表記する．
例えば，IPアドレスの上位25ビットがネットワーク部であった場合，サブネットマスクの上位25ビットを1に，下位7ビットを0にした「255.255.255.128」がサブネットマスクということになる．
これにより，ネットワーク部のビット長をクラスに縛られることなく柔軟に変更することができるようになった．

\subsection{L2スイッチ}

L2スイッチとは，同一ネットワーク内でブリッジの役割を持つネットワークデバイスのことであり，基本的にレイヤ2の情報を用いて処理を行う\cite{masteringtcpip}．
ホストからL2スイッチに送られたフレームは，L2スイッチ内によってそのフレームの宛先MACアドレスを解析され，どの物理ポートから転送されるかが決定される．
この時，L2スイッチ内では転送ポート決定の際に，MACアドレスと接続物理ポートの組を記したテーブルを参照する．
これを転送表（フォワーディングテーブル）と呼び，全てのL2スイッチが個々に保持している．

一般的なL2スイッチは，パケットを受け取った際に，送信元MACアドレスと入力物理ポートの組を転送表に記録する．
なぜならば，あるMACアドレスAが送信元のフレームを物理ポートBで受け取ったという事は，その物理ポートBの先にMACアドレスAを持つホストが存在していることを意味し，今後そのMACアドレスAが宛先の場合，物理ポートBから転送すれば，確実にMACアドレスAのホストに到達すると考えてもよいからである．
この考え方に基づいた転送表の記録を自己学習といい，この自己学習の積み重ねによってL2スイッチは賢くなっていく．
もし，宛先MACアドレスが転送表にない場合は，入力ポート以外の全ての物理ポートに転送するフラッディング動作を行い，他のネットワーク機器からの応答を待つ．